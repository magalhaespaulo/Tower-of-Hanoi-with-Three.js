<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/Stats.js" type="text/javascript"></script>
		<script src="js/Tween.js" type="text/javascript"></script>
		<script src="js/greensock/TweenMax.min.js" type="text/javascript"></script>
		<script src="js/jquery-1.8.2.min.js" type="text/javascript"></script>

		<script>

			var container, stats;
			var camera,controls, scene, projector, renderer;

			var mouse = { x: 0, y: 0 }, INTERSECTED;
			
			var geometry, cube, object, obj;

var tAarray = [];
var tBarray = [];
var tCarray = [];
var discos = [];
var movimentos = [];
var movimentos_count = 1;
var aux = 0;
var automatico=true;
var quantidade_discos = 3;
var escolher_quantidade_discos = [12,3,4,5,6,7,8,9,10,11,12,13,14,15];
var spaco = 6;
var velocidadeTorres = .2;
var cores_discos=[0xCC0000,0x009900,0x3333FF,0x993366,0x666666];

pre_init();

function pre_init(){
	
	container = document.createElement( 'div' );
				document.body.appendChild( container );
 

	var textos = document.createElement( 'div' );
	textos.style.position = 'absolute';
	textos.style.top = '20px';
	textos.style.width = '100%';
	textos.style.textAlign = 'center';
	textos.id = 'textos';
	textos.innerHTML = '<input type="checkbox" id="automatico" checked>Automatico</input><div id"infors"><select id="select"></select><input type="button" id="iniciar" value="Iniciar" onclick="alert_selected()" /></div>';
	container.appendChild( textos );


	var select = document.getElementById("select");
	for(index in escolher_quantidade_discos) {
		select.options[select.options.length] = new Option( escolher_quantidade_discos[index], escolher_quantidade_discos[index] );
	}
	
	

}
function alert_selected(){
		var select = document.getElementById("select");
		quantidade_discos = select.options[select.selectedIndex].value;
		
		automatico = document.getElementById("automatico").checked;


		$('#select').remove();
		$('#iniciar').remove();
		document.getElementById('textos').innerHTML = '<div>Movimento: <b id="movimentos">0</b></div>';
		

		init_3D();
		animate();

}
			function init_3D( ) {

			

 /*
var torreA = document.createElement( 'div' );
torreA.style.position = 'absolute';
torreA.style.top = '20px';
torreA.style.width = '100%';
torreA.style.textAlign = 'center';
torreA.innerHTML = '<div id="torreA">Torre A</div>';
container.appendChild( torreA );

var torreB = document.createElement( 'div' );
torreB.style.position = 'absolute';
torreB.style.top = '60px';
torreB.style.width = '100%';
torreB.style.textAlign = 'center';
torreB.innerHTML = '<div id="torreB">Torre B</div>';
container.appendChild( torreB );

var torreC = document.createElement( 'div' );
torreC.style.position = 'absolute';
torreC.style.top = '100px';
torreC.style.width = '100%';
torreC.style.textAlign = 'center';
torreC.innerHTML = '<div id="torreC">Torre C</div>';
container.appendChild( torreC );
*/

/*
				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = '<a href="http://github.com/mrdoob/three.js" target="_blank">three.js</a> webgl - interactive cubes';
				container.appendChild( info );*/

				
				//camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 10000 );
				//camera.position.set( 0, 0, 800 );
				/*
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.z = 400;*/
				
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 50;
				camera.position.z = 300;
				
				controls = new THREE.OrbitControls( camera );
				

				/*
				var radius = 100;
				var theta = 0;
				
				camera.position.x = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );*/
				

/*
camera = new THREE.Camera( 45, window.innerWidth / window.innerHeight, 1, 3800 );
camera.position.y = 50;
camera.position.z = 2500;
camera.target.position.y = 50;*/
				

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( -1, -1, -1 ).normalize();
				scene.add( light );

// Setup a timeline object with 0.2s stagger. Also reverse on complete.
var tl = new TimelineLite(),
    tweens = [];
				geometry = new THREE.TorusGeometry( 40, 8, 25 );
				cube = new THREE.CubeGeometry( 40, 8, 25 );
/**/j=11;
				for ( var i = 0; i<quantidade_discos; i ++ ) {
/*
					object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
					object.name = "disco_"+i;
					object.id = i;

					//object.position.x = Math.random() * 800 - 400;
					//object.position.y = Math.random() * 800 - 400;
					//object.position.z = Math.random() * 800 - 400;

					//object.rotation.x = ( Math.random() * 360 ) * Math.PI / 180;
					//object.rotation.y = ( Math.random() * 360 ) * Math.PI / 180;
					//object.rotation.z = ( Math.random() * 360 ) * Math.PI / 180;


//object.rotation.x = ( i * 360 ) * Math.PI / 180;

					//object.scale.x = Math.random() + 0.5;
					//object.scale.y = Math.random() + 0.5;
					//object.scale.z = Math.random() + 0.5;
					
					object.scale.set((j/2)*.1,(j/2)*.1,(2)*.1);////////<<<
					j--;
					
					object.rotation.x = 90;

					object.position.set(0,-10+i*4,0);
					//object.position.set(i*10,-50+i*10,-i*20);
					object.rotationAutoUpdate = false;
					object.castShadow = true;
					object.receiveShadow  = false;
					
				
					scene.add( object );*/

					
					
// Push our tween on to an array for later.
//tweens.push( TweenLite.to(object.rotation, .5, { 
//y: -Math.PI*2,
//ease: Cubic.easeOut})
//);
				}

base = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 /*Math.random() * 0xffffff*/ } ) );

base.position.set(0,-5,0);
base.scale.set(4,6,.2);
base.rotation.x = 90;
scene.add( base );


cube1 = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );

cube1.position.set(-50,15,15);
cube1.scale.set(.2,.8,2);
cube1.rotation.x = 90;
cube1.name = "A";
scene.add( cube1 );

cube2 = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
cube2.position.set(0,20,15);
cube2.scale.set(.2,.8,2.2);
cube2.rotation.x = 90;
cube2.name = "B";
scene.add( cube2 );

cube3 = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
cube3.position.set(50,25,15);
cube3.scale.set(.2,.8,2.5);
cube3.rotation.x = 90;
cube3.name = "C";
scene.add( cube3 );

	
j = quantidade_discos-1;
for ( var i = 0; i<quantidade_discos; i++ ) {
var aaa = .4+(i/40);
	var disco = "disco"+i;
	eval(disco + " = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff  } ) )"); //cores_discos[i]
	eval(disco + ".scale.set(aaa,aaa,aaa)");
	eval(disco + ".rotation.x = 90");
	eval(disco + ".position.set(-50,j*spaco,5-i)");
	eval(disco + ".id = i");
	scene.add( eval(disco) );
	
	
	tAarray.push( eval(disco).id );
	j--;
}
//alert(tAarray[2]);
/*
alert(disco1.id);
alert(disco2.id);
alert(disco3.id);*/
/*
disco1 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
disco1.scale.set(.4,.4,.4);
disco1.rotation.x = 90;
disco1.position.set(-50,5,0);
disco1.name = "disco_1";
disco1.id = 1;
scene.add( disco1 );


disco2 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
disco2.scale.set(.45,.45,.45);
disco2.rotation.x = 90;
disco2.position.set(-50,0,0);
disco2.name = "disco_2";
disco2.id = 2;
scene.add( disco2 );

disco3 = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
disco3.scale.set(.5,.5,.5);
disco3.rotation.x = 90;
disco3.position.set(-50,-5,0);
disco3.name = "disco_3";
disco3.id = 3;
scene.add( disco3 );
*/

//tAarray.reverse();
//alert(tAarray);
/*
tAarray.sort(function(a,b){return a-b});

alert(tAarray);

tAarray.shift();

alert(tAarray);
*/
/*
tweens.push( TweenLite.to(disco1.position, .35, { y: Math.random() * 100 - 50, ease: Cubic.easeInOut}));
tweens.push( TweenLite.to(disco2.position, .35, { y: Math.random() * 100 - 50, ease: Cubic.easeInOut}));
tweens.push( TweenLite.to(disco3.position, .35, { y: Math.random() * 100 - 50, ease: Cubic.easeInOut}));
*/
/*
	var teste = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
	teste.scale.set((7/2)*.1,(7/2)*.1,(2)*.1);////////<<<
	teste.rotation.x = 90;
	teste.position.set(0,-10+4*4,0);
	
	scene.add( teste );*/
	



				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer();
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeydown, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				
TweenLite.ticker.addEventListener("tick", render);


// Insert our tweens. The sequence will auto start, and stagger with a 0.2s delay in between.
//tl.insertMultiple(tweens, 1, 'start', .2);

				init_solution();
			}
			
			


/*
function vai_c(name) {

		if ( name == "disco_1" ) obj = disco1;
		if ( name == "disco_2" ) obj = disco2;
		if ( name == "disco_3" ) obj = disco3;
		
		TweenLite.to(obj.position, .5, { x: 50, ease:SlowMo.ease.config(0.2, 0.2), delay:.5, onComplete:espera( obj.name )} );
}

function espera( name ){

		if ( name == "disco_1" ) obj = disco1;
		if ( name == "disco_2" ) obj = disco2;
		if ( name == "disco_3" ) obj = disco3;
}*/

function subir( disco, torre ) {

	for ( var i = 0; i<quantidade_discos; i++ ) {
		if ( disco == i ){
			var objeto = "disco"+i;
			obj = eval(objeto);
		}
	}


	if(obj.position.x == -50) { tAarray.shift(); //alert( 'Torre A tem '+tAarray.length+' discos: '+tAarray);
		//torre = 'A';
	}
	if(obj.position.x == 0) { tBarray.shift(); //alert( 'Torre B tem '+tBarray.length+' discos: '+tBarray);
		//torre = 'B';
	}
	if(obj.position.x == 50) { tCarray.shift(); //alert( 'Torre C tem '+tCarray.length+' discos: '+tCarray);
		//torre = 'C';
	}

		
		//TweenLite.to(obj.position, 1, { y: 50, ease:Expo.easeOut, delay:0} );

		if ( torre == 'A' ) TweenLite.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, delay:velocidadeTorres+.05, onComplete: torre_A} );
		if ( torre == 'B' ) TweenLite.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, delay:velocidadeTorres+.05, onComplete: torre_B} );
		if ( torre == 'C' ) TweenLite.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, delay:velocidadeTorres+.05, onComplete: torre_C} );
		else TweenLite.to(obj.position, velocidadeTorres, { y: 100,ease:Expo.easeOut, delay:velocidadeTorres} );

		if ( !automatico )
		{
			document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mousedown', onDocumentMouseDownTorres, false );
		}
		//alert(torre);

}

function descer( torre )
{
	if ( torre == 'A' || torre == 'B' || torre == 'C')
	{
		if ( torre == 'A' ) torre_A(obj);
		if ( torre == 'B' ) torre_B(obj);
		if ( torre == 'C' ) torre_C(obj);
		
		document.removeEventListener( 'mousedown', onDocumentMouseDownTorres, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		obj = null;
	}
}


function proximo()
{
	if ( automatico && discos.length-1 > aux )
	{
		aux++;
		subir( discos[aux]-1, movimentos[aux] );
	}

}

function init_solution()
{
	function hanoiArray(disco, inicio, temp, fim ){

		if ( disco == 1 ) {
			discos.push(disco); movimentos.push(fim);
		} else {
			hanoiArray( disco-1, inicio, fim, temp );
			discos.push(disco); movimentos.push(fim);
			hanoiArray( disco-1, temp, inicio, fim );
		}
	}
	hanoiArray(quantidade_discos, 'A','B','C');

	if ( automatico ) subir( discos[aux]-1, movimentos[aux] );
	
	//alert('Menor solução: '+movimentos.length+' movimentos.');
}




function torre_A() {

	TweenLite.to(obj.position, velocidadeTorres, { x: -50,  z:10,  ease:Expo.easeOut, delay:0} );
	TweenLite.to(obj.position, velocidadeTorres, { y: tAarray.length*spaco, z:10, ease:Bounce.easeOut, delay:velocidadeTorres, onComplete: proximo} );

	tAarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tAarray.push(obj.id);
	//tAarray.sort(function(a,b){return a-b});
	//alert( 'Torre A tem '+tAarray.length+' discos: '+tAarray);
	
}
function torre_B() {

	TweenLite.to(obj.position, velocidadeTorres, { x: 0, z:10, ease:Expo.easeOut, delay:0});
	TweenLite.to(obj.position, velocidadeTorres, { y: tBarray.length*spaco, z:10, ease:Bounce.easeOut, delay:velocidadeTorres, onComplete: proximo});
	
	tBarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tBarray.push(obj.id);
	//tBarray.sort(function(a,b){return a-b});
	//alert( 'Torre B tem '+tBarray.length+' discos: '+tBarray);
	
}
function torre_C() {

	TweenLite.to(obj.position, velocidadeTorres, { x: 50, z:10, ease:Expo.easeOut, delay:0} );
	TweenLite.to(obj.position, velocidadeTorres, { y: tCarray.length*spaco, z:10, ease:Bounce.easeOut, delay:velocidadeTorres, onComplete: proximo} );
	
	
	tCarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tCarray.push(obj.id);
	//tCarray.sort(function(a,b){return a-b});
	//alert( 'Torre C tem '+tCarray.length+' discos: '+tCarray);
	
}



/*
$("#torreA").click(function() {
	torre_a();
	
});
$("#torreB").click(function() {
	torre_b();
	
});
$("#torreC").click(function() {
	torre_c();
	
});
*/

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				


			}

			//

			function onDocumentMouseDownTorres( event ) {

				event.preventDefault();
				

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{

					descer( intersects[0].object.name );//subir( intersects[0].object.name, intersects[0].object.id );

				}

			}
			
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{
/*
					new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
						//x: Math.random() * 50 - 25,
						//z: Math.random() * 50 - 25,
						y: Math.random() * 50 - 25 }, 1000 )
					.easing( TWEEN.Easing.Cubic.EaseOut).start();*/
/*
					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: ( Math.random() * 360 ) * Math.PI / 180,
						y: ( Math.random() * 360 ) * Math.PI / 180,
						z: ( Math.random() * 360 ) * Math.PI / 180 }, 1000 )
					.easing( TWEEN.Easing.Elastic.EaseOut).start();*/
//alert( intersects[0].object.name );
/*
if(intersects[0].object.position.x == -50) torre = 'torre A';
if(intersects[0].object.position.x == 0) torre = 'torre B';
if(intersects[0].object.position.x == 50) torre = 'torre C';
*/
subir( intersects[0].object.id );//subir( intersects[0].object.name, intersects[0].object.id );


//TweenLite.to(intersects[0].object.position, .5, { y: 50, ease: Sine.easeOut, onComplete:vai_c( intersects[0].object.name )});





					
					//alert(intersects[0].object.name);
					
					

					
					//a_c(intersects[ 0 ].object);
//intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );



					
					
					//alert("you clicked particle named '" + intersects[0].object.name + "' with id: " + intersects[0].object.id);

				}

			}





			
			function onDocumentKeydown( event ) {

				switch(event.keyCode) {
					case 32: paused = paused ? false : true; break;
					case 38: camera.position.z -= 10; break;
					case 40: camera.position.z += 10; break;
				}
			}



			function animate() {

				requestAnimationFrame( animate );
				controls.update();
				
				render();
				stats.update();

			}


			var radius = 100;
			var theta = 0;



			function render() {

				theta += 0.2;
				
				
TWEEN.update();////////////////

/**/
				scene.position.y = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				scene.position.x = radius * Math.sin( (mouse.x*30) * Math.PI / 360 );
				scene.position.z = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				/*camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );*/

				camera.lookAt( scene.position );

				// find intersections

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//INTERSECTED.material.emissive.setHex( 0xff0a00 );

					}


				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
