<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/Stats.js" type="text/javascript"></script>
		<script src="js/Tween.js" type="text/javascript"></script>
		<script src="js/greensock/TweenMax.min.js" type="text/javascript"></script>
		
		<script src="js/jquery-1.8.2.min.js" type="text/javascript"></script>

		<script>

			var container, stats;
			var camera,controls, scene, projector, renderer;

			var mouse = { x: 0, y: 0 }, INTERSECTED;
			
			var geometry, cube, object, obj;

var tAarray = [];
var tBarray = [];
var tCarray = [];
var discos = [];
var movimentos = [];
var movimentos_count = 1;
var aux = 0;
var automatico=true;
var quantidade_discos = 3;
var escolher_quantidade_discos = [7,3,4,5,6,7,8,9,10,11,12,13,14,15];
var spaco = 6;
var velocidadeTorres = .12;
var cores_discos=[0xCC0000,0x009900,0x3333FF,0x993366,0x666666];

var altura_torres = 100;
var torre_a_x = -altura_torres; //*altura_torres*.02;
var torre_b_x = 0;
var torre_c_x = altura_torres;

var base, torreA, torreB, torreC;

var tl = new TimelineLite();

pre_init();
init();

function pre_init(){
	
	container = document.createElement( 'div' );
	document.body.appendChild( container );
 

	var textos = document.createElement( 'div' );
	textos.style.position = 'absolute';
	textos.style.top = '20px';
	textos.style.width = '100%';
	textos.style.textAlign = 'center';
	textos.id = 'textos';
	textos.innerHTML = '<input type="checkbox" id="automatico" checked="checked">Automatico</input><div id"infors"><select id="select"></select><input type="button" id="iniciar" value="Iniciar" onclick="init()" /></div>';
	container.appendChild( textos );//


	var select = document.getElementById("select");
	for(index in escolher_quantidade_discos) {
		select.options[select.options.length] = new Option( escolher_quantidade_discos[index], escolher_quantidade_discos[index] );
	}
}
function init(){
		var select = document.getElementById("select");
		quantidade_discos = select.options[select.selectedIndex].value;
		
		automatico = document.getElementById("automatico").checked;


		$('#select').remove();
		$('#iniciar').remove();
		document.getElementById('textos').innerHTML = '<div>Movimento: <b id="movimentos">0</b></div>';
		
		
		init_3D();
		animate();
		init_solution();
}
			function init_3D( )
			{

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 50;
				camera.position.z = 300;
				
				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( -1, -1, -1 ).normalize();
				scene.add( light );

				geometry = new THREE.TorusGeometry( 20, 4, 25 );
				cube_base = new THREE.CubeGeometry( altura_torres*4, altura_torres, 2 );
				cube = new THREE.CubeGeometry( 8*altura_torres*.01, 8*altura_torres*.01, altura_torres );

				base = new THREE.Mesh( cube_base, new THREE.MeshLambertMaterial( { color: 0x663300 /*Math.random() * 0xffffff*/ } ) );
				base.position.set(0,-3,0);
				base.rotation.x = -Math.PI/2;
				scene.add( base );
				torreA = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreA.position.set(torre_a_x, altura_torres/2-3, 0);
				torreA.rotation.set(-Math.PI/2, 0, 0);
				torreA.name = "A";
				scene.add( torreA );
				torreB = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreB.position.set(torre_b_x, altura_torres/2-3, 0);
				torreB.rotation.set(-Math.PI/2, 0, 0);
				torreB.name = "B";
				scene.add( torreB );
				torreC = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreC.position.set(torre_c_x, altura_torres/2-3, 0);
				torreC.rotation.set(-Math.PI/2, 0, 0);
				torreC.name = "C";
				scene.add( torreC );

				for ( var i = 0; i<quantidade_discos; i++ )
				{ // = ( Math.random() * 360 ) * Math.PI / 180;
					var disco = "disco"+i;
					eval(disco + " = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff  } ) )"); //cores_discos[i]
					eval(disco + ".rotation.x = 90 * Math.PI / 180");
					eval(disco + ".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");
					eval(disco + ".scale.set(.7+i*altura_torres*.002,.7+i*altura_torres*.002,.7+altura_torres*.002)");
					
					eval(disco + ".id = i");
					scene.add( eval(disco) );

					tAarray.push( eval(disco).id );
				}

				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer();
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeydown, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				
TweenLite.ticker.addEventListener("tick", render);


// Insert our tweens. The sequence will auto start, and stagger with a 0.2s delay in between.
//tl.insertMultiple(tweens, 1, 'start', .2);

				
			}
			
			


/*
function vai_c(name) {

		if ( name == "disco_1" ) obj = disco1;
		if ( name == "disco_2" ) obj = disco2;
		if ( name == "disco_3" ) obj = disco3;
		
		TweenLite.to(obj.position, .5, { x: 50, ease:SlowMo.ease.config(0.2, 0.2), delay:.5, onComplete:espera( obj.name )} );
}

function espera( name ){

		if ( name == "disco_1" ) obj = disco1;
		if ( name == "disco_2" ) obj = disco2;
		if ( name == "disco_3" ) obj = disco3;
}*/

function subir( disco, torre ) {

	/*for ( var i = 0; i<quantidade_discos; i++ ) {
		if ( disco == i ){
			var objeto = "disco"+i;
			obj = eval(objeto);
		}
	}
	*/obj = eval("disco"+disco);
	
	


	if(obj.position.x == torre_a_x) { tAarray.shift(); //alert( 'Torre A tem '+tAarray.length+' discos: '+tAarray);
		//torre = 'A';
	}
	if(obj.position.x == torre_b_x) { tBarray.shift(); //alert( 'Torre B tem '+tBarray.length+' discos: '+tBarray);
		//torre = 'B';
	}
	if(obj.position.x == torre_c_x) { tCarray.shift(); //alert( 'Torre C tem '+tCarray.length+' discos: '+tCarray);
		//torre = 'C';
	}

		
		//TweenLite.to(obj.position, 1, { y: 50, ease:Expo.easeOut, delay:0} );

		if ( torre == 'A' ) tl.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, onComplete: torre_A} );
		if ( torre == 'B' ) tl.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, onComplete: torre_B} );
		if ( torre == 'C' ) tl.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut, onComplete: torre_C} );
		else tl.to(obj.position, velocidadeTorres, { y: 100, ease:Expo.easeOut } );

		if ( !automatico )
		{
			document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'mousedown', onDocumentMouseDownTorres, false );
		}
		//alert(torre);

}

function descer( torre )
{
	if ( torre == 'A' || torre == 'B' || torre == 'C')
	{
		if ( torre == 'A' ) torre_A(obj);
		if ( torre == 'B' ) torre_B(obj);
		if ( torre == 'C' ) torre_C(obj);
		
		document.removeEventListener( 'mousedown', onDocumentMouseDownTorres, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		obj = null;
	}
}


function proximo()
{
	if ( automatico && discos.length-1 > aux )
	{
		aux++;
		subir( discos[aux]-1, movimentos[aux] );
	}

}

function init_solution()
{
	function hanoiArray(disco, inicio, temp, fim ){

		if ( disco == 1 ) {
			discos.push(disco); movimentos.push(fim);
		} else {
			hanoiArray( disco-1, inicio, fim, temp );
			discos.push(disco); movimentos.push(fim);
			hanoiArray( disco-1, temp, inicio, fim );
		}
	}
	hanoiArray(quantidade_discos, 'A','B','C');

	if ( automatico ) subir( discos[aux]-1, movimentos[aux] );
	
	//alert('Menor solução: '+movimentos.length+' movimentos.');
}




function torre_A() {

	tl.to(obj.position, velocidadeTorres*2, { bezier:{values:[{x:torre_a_x/2, y:altura_torres*2}, {x:torre_a_x, y:altura_torres+20}]}, ease:Expo.easeOut } );
	tl.to(obj.position, velocidadeTorres/2, { y: tAarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo} );

	tAarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tAarray.push(obj.id);
	//tAarray.sort(function(a,b){return a-b});
	//alert( 'Torre A tem '+tAarray.length+' discos: '+tAarray);
	
}
function torre_B() {

	tl.to(obj.position, velocidadeTorres*2, { bezier:{values:[{x:torre_b_x/2, y:altura_torres*2}, {x:torre_b_x, y:altura_torres+20}]}, ease:Expo.easeOut });
	tl.to(obj.position, velocidadeTorres/2, { y: tBarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo});
	
	tBarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tBarray.push(obj.id);
	//tBarray.sort(function(a,b){return a-b});
	//alert( 'Torre B tem '+tBarray.length+' discos: '+tBarray);
	
}
function torre_C() {

	tl.to(obj.position, velocidadeTorres*2, { bezier:{values:[{x:torre_c_x/2, y:altura_torres*2}, {x:torre_c_x, y:altura_torres+20}]}, ease:Expo.easeOut } );
	tl.to(obj.position, velocidadeTorres/2, { y: tCarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo} );
	
	
	tCarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
	//tCarray.push(obj.id);
	//tCarray.sort(function(a,b){return a-b});
	//alert( 'Torre C tem '+tCarray.length+' discos: '+tCarray);
	
}



/*
$("#torreA").click(function() {
	torre_a();
	
});
$("#torreB").click(function() {
	torre_b();
	
});
$("#torreC").click(function() {
	torre_c();
	
});
*/

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				


			}

			//

			function onDocumentMouseDownTorres( event ) {

				event.preventDefault();
				

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{

					descer( intersects[0].object.name );//subir( intersects[0].object.name, intersects[0].object.id );

				}

			}
			
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{
/*
					new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
						//x: Math.random() * 50 - 25,
						//z: Math.random() * 50 - 25,
						y: Math.random() * 50 - 25 }, 1000 )
					.easing( TWEEN.Easing.Cubic.EaseOut).start();*/
/*
					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: ( Math.random() * 360 ) * Math.PI / 180,
						y: ( Math.random() * 360 ) * Math.PI / 180,
						z: ( Math.random() * 360 ) * Math.PI / 180 }, 1000 )
					.easing( TWEEN.Easing.Elastic.EaseOut).start();*/
//alert( intersects[0].object.name );
/*
if(intersects[0].object.position.x == -50) torre = 'torre A';
if(intersects[0].object.position.x == 0) torre = 'torre B';
if(intersects[0].object.position.x == 50) torre = 'torre C';
*/
subir( intersects[0].object.id );//subir( intersects[0].object.name, intersects[0].object.id );


//TweenLite.to(intersects[0].object.position, .5, { y: 50, ease: Sine.easeOut, onComplete:vai_c( intersects[0].object.name )});





					
					//alert(intersects[0].object.name);
					
					

					
					//a_c(intersects[ 0 ].object);
//intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );



					
					
					//alert("you clicked particle named '" + intersects[0].object.name + "' with id: " + intersects[0].object.id);

				}

			}





			
			function onDocumentKeydown( event ) {

				switch(event.keyCode) {
					case 32: paused = paused ? false : true; break;
					case 38: camera.position.z -= 10; break;
					case 40: camera.position.z += 10; break;
				}
			}



			function animate() {

				requestAnimationFrame( animate );
				controls.update();
				
				render();
				stats.update();

			}


			var radius = 100;
			var theta = 0;



			function render() {

				theta += 0.2;
				
				
TWEEN.update();////////////////

/**/
				scene.position.y = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				scene.position.x = radius * Math.sin( (mouse.x*30) * Math.PI / 360 );
				scene.position.z = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				/*camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );*/

				camera.lookAt( scene.position );

				// find intersections

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//INTERSECTED.material.emissive.setHex( 0xff0a00 );

					}


				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
