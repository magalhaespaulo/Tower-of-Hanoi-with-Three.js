<!DOCTYPE html>
<html lang="pt-BR">
	<head>
		<title>Tower of Hanoi with Three.js</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/Stats.js" type="text/javascript"></script>
		<script src="js/Tween.js" type="text/javascript"></script>
		<script src="js/greensock/TweenMax.min.js" type="text/javascript"></script>
		<script src="js/jquery-1.8.2.min.js" type="text/javascript"></script>
		<script src="js/dat.gui.min.js" type="text/javascript"></script>

		<script>

		var container, stats, camera, controls, scene, projector, renderer, NEAR = 5, FAR = 2000,
		
		light, SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024,
		MARGIN = 100, SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight - 2 * MARGIN, FLOOR = -250,


		mouse = new THREE.Vector2(), offset = new THREE.Vector3(), INTERSECTED, SELECTED,

		geometry, cube, object, discoSuspenso,

		automatico=true,
		tamanho = 8,
		quantidadeDiscos = 5,
		velocidadeTorres = .375,
		escolherQuantidadeDiscos = [quantidadeDiscos,3,4,5,6,7,8,9,10,11,12,13,14,15],
		cores_discos=[0xCC0000,0x009900,0x3333FF,0x993366,0x666666],

		base, torres = ['A','B','C'], altura_torres = 50*(quantidadeDiscos*.25), torre_A_x = -altura_torres*1.5, torre_B_x = 0, torre_C_x = altura_torres*1.5,
		tAarray = [], tBarray = [], tCarray = [], discos = [], movimentos_origem = [], movimentos_destino = [],
		movimentos_print = 1, movimentos_count = 0,

		tl = new TimelineLite(),

		torresObjs = [], discosObjs = [], intersectsObjs = [],
		
		radius = 100, theta = 0;

		//let's rock
			pre_init();
			init();

		//pre_init
			function pre_init()
			{
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var textos = document.createElement( 'div' );
				textos.style.position = 'absolute';
				textos.style.top = '20px';
				textos.style.width = '100%';
				textos.style.textAlign = 'center';
				textos.id = 'textos';
				textos.innerHTML = '<input type="checkbox" id="automatico" checked="checked">Automatico</input><div id"infors"><select id="select"></select><input type="button" id="iniciar" value="Iniciar" onclick="init()" /></div>';
				container.appendChild( textos );

				var select = document.getElementById("select");
				for(index in escolherQuantidadeDiscos) {
					select.options[select.options.length] = new Option( escolherQuantidadeDiscos[index], escolherQuantidadeDiscos[index] );
				}
			}

		//init
			function init()
			{
				var select = document.getElementById("select");
				quantidadeDiscos = select.options[select.selectedIndex].value;
				automatico = document.getElementById("automatico").checked;

				$('#select').remove();
				$('#iniciar').remove();
				document.getElementById('textos').innerHTML = '<div>Movimento: <b id="movimentos">0</b></div>';

				init_3D();
				animate();
				init_solution();
			}

		//init_3D
			function init_3D( )
			{
				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, NEAR, FAR );
				camera.position.set( 300, 350, 600 );

				controls = new THREE.OrbitControls( camera );

				//scene
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog( 0xffaa55, 1000, FAR );
				THREE.ColorUtils.adjustHSV( scene.fog.color, 0.02, -0.15, -0.65 );

				//lights
				var ambient = new THREE.AmbientLight( 0x222222 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff, 1,0, Math.PI, 1 );
				light.position.set( 200, 1500, 1000 );
				light.target.position.set( 0, 0, 0 );

				light.castShadow = true;

				light.shadowCameraNear = 1000;
				light.shadowCameraFar = camera.far;
				light.shadowCameraFov = 15;

				//light.shadowCameraVisible = true;

				light.shadowBias = 0.0001;
				light.shadowDarkness = 0.5;

				light.shadowMapWidth = SHADOW_MAP_WIDTH;
				light.shadowMapHeight = SHADOW_MAP_HEIGHT;

				scene.add( light );

				//piso
				var piso = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100, 100 ), new THREE.MeshPhongMaterial( { color: 0xffdd99 } ) );
				piso.position.set( 0, -10, 0 );
				piso.rotation.x = -Math.PI / 2;
				piso.scale.set( 50, 50, 50 );
				piso.castShadow = false;
				piso.receiveShadow = true;
				piso.doubleSided = true;
				scene.add( piso );
				
				//base
				var base = new THREE.Mesh( new THREE.CubeGeometry( altura_torres*6, altura_torres*2, 12 ), new THREE.MeshLambertMaterial( { color: 0x663300 /*Math.random() * 0xffffff*/ } ) );
				base.position.set(0,-8,0);
				base.rotation.x = -Math.PI/2;
				base.castShadow = true;
				base.receiveShadow = true;
				scene.add( base );

				//torres
				for (var i in torres)
				{
					eval("torre"+torres[i] + " = new THREE.Mesh( new THREE.CylinderGeometry(6, 6, altura_torres, 12, false), new THREE.MeshLambertMaterial( { color: 0x663300 } ) )");
					eval("torre"+torres[i] + ".position.set(torre_"+torres[i]+"_x, altura_torres/2-2, 0)");
					eval("torre"+torres[i] + ".name = torres[i]");
					eval("torre"+torres[i] + ".castShadow = true");
					eval("torre"+torres[i] + ".receiveShadow = true");
					torresObjs.push( eval("torre"+torres[i]) );
					intersectsObjs.push( eval("torre"+torres[i]) );
					scene.add( eval("torre"+torres[i]) );
				}

				//discos
				for ( var i = 0; i<quantidadeDiscos; i++ )
				{
					var arcShape = new THREE.Shape();
					arcShape.absarc( 0, 0, 20+(i*4), 0, Math.PI*2, false );
					var holePath = new THREE.Shape();
					holePath.absarc( 0, 0,18, 0, Math.PI*2, true );
					arcShape.holes.push( holePath );
					
					var smooth = new THREE.ExtrudeGeometry( arcShape, extrudeSettings = { amount: tamanho/3, steps: 2, bevelSegments: 22, bevelSize: 11, bevelThickness: tamanho/3 } );
					/*	smooth.mergeVertices();
					var modifier = new THREE.SubdivisionModifier();
						modifier.modify( smooth );*/
					eval("disco"+i + " = new THREE.Mesh( smooth, new THREE.MeshLambertMaterial( { color: cores_discos[i]  } ) )"); //Math.random() * 0xffffff
					eval("disco"+i + ".rotation.x = -Math.PI/2");// = ( Math.random() * 360 ) * Math.PI / 180;
					eval("disco"+i + ".position.set(torre_A_x,altura_torres*5,0)");
					eval("disco"+i + ".id = i");
					eval("disco"+i + ".name = 'A'");
					eval("disco"+i + ".castShadow = true");
					eval("disco"+i + ".receiveShadow = true");
					scene.add( eval("disco"+i) );
					discosObjs.push( eval("disco"+i) );
					intersectsObjs.push( eval("disco"+i) );
					tAarray.push( eval("disco"+i).id );
				}
				//discos tween
				j = quantidadeDiscos-1;
				for ( var i = 0; i<quantidadeDiscos; i++ )
				{
					tl.to(eval("disco"+j).position, velocidadeTorres, { y: i*tamanho, ease:Strong.easeOut } );
					j--;
				}
				tl.from(camera.position, velocidadeTorres*6, { x: 300, y: 200, z: -180, ease:Strong.easeInOut } );
				
				

				//projector
				projector = new THREE.Projector();

				//renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );
				//renderer.domElement.style.position = "relative";
				//renderer.domElement.style.top = MARGIN + 'px';
				container.appendChild( renderer.domElement );
				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = true;
				container.appendChild(renderer.domElement);

				//stats
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				if ( !automatico ) document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				//document.addEventListener( 'keydown', onDocumentKeydown, false );

				window.addEventListener( 'resize', onWindowResize, false );
				
				TweenLite.ticker.addEventListener("tick", render);
			}

		//_subir
			function _subir( disco, origem, destino )
			{	//console.log(origem + " " +destino);//console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
				eval("t"+origem+"array").sort().shift();

				if ( automatico )
					tl.to(eval("disco"+disco).position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn, onComplete: _torre, onCompleteParams:[eval("disco"+disco),destino] } );
				else {
					discoSuspenso = eval("disco"+disco);
					tl.to(eval("disco"+disco).position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn } );
					document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
					document.addEventListener( 'mousedown', onDocumentMouseDownTowers, false );
				}
			}
		//torre
			function _torre ( obj, destino )
			{
				tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:eval("torre_"+destino+"_x")/2, y:altura_torres*2}, {x:eval("torre_"+destino+"_x"), y:altura_torres+10}]}, ease:Quart.easeOut } );
				tl.to(obj.position, velocidadeTorres/2, { y: eval("t"+destino+"array").length*tamanho, ease:Bounce.easeOut, onComplete: proximo} );
				eval("t"+destino+"array").unshift(obj.id);
				document.getElementById('movimentos').innerHTML = movimentos_print++;
			}

		//proximo
			function proximo()
			{
				if ( automatico && discos.length-1 > movimentos_count )
				{
					movimentos_count++;
					_subir( discos[movimentos_count]-1, movimentos_origem[movimentos_count], movimentos_destino[movimentos_count] );
					
				}else{
					console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
				}
			}

		//init_solution
			function init_solution()
			{
				function hanoiArray(disco, inicio, temp, fim ){

					if ( disco == 1 ) {
						discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
					} else {
						hanoiArray( disco-1, inicio, fim, temp );
						discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
						hanoiArray( disco-1, temp, inicio, fim );
					}
				}
				hanoiArray(quantidadeDiscos, 'A','B','C');

				if ( automatico ) _subir( discos[movimentos_count]-1, movimentos_origem[movimentos_count], movimentos_destino[movimentos_count] );
			}

		//onWindowResize
			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

		//onDocumentMouseMove
			function onDocumentMouseMove( event )
			{
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

		//onDocumentMouseDown
			function onDocumentMouseDown( event )
			{
				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( discosObjs );
				
				if ( intersects.length > 0 ) _subir( intersects[0].object.id, intersects[0].object.name );
			}

		//onDocumentMouseDownTowers
			function onDocumentMouseDownTowers( event )
			{
				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( torresObjs );

				if ( intersects.length > 0 )
				{	
					discoSuspenso.name = intersects[0].object.name;
					_torre( discoSuspenso, intersects[0].object.name );
					document.removeEventListener( 'mousedown', onDocumentMouseDownTowers, false );
					document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				}
			}

		//onDocumentKeydown
			function onDocumentKeydown( event )
			{
				switch(event.keyCode)
				{
					case 32: paused = paused ? false : true; break;
					case 38: camera.position.z -= 10; break;
					case 40: camera.position.z += 10; break;
				}
			}

		//animate
			function animate()
			{
				requestAnimationFrame( animate );
				controls.update();
				
				render();
				stats.update();
			}

		//render
			function render()
			{
				theta += 0.2;
				
				TWEEN.update();

				scene.position.y = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				scene.position.x = radius * Math.sin( (mouse.x*30) * Math.PI / 360 );
				scene.position.z = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				//console.log("x: "+camera.position.x+"  y: "+camera.position.y+"  z: "+camera.position.z);

				camera.lookAt( scene.position );

				// find intersections
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( intersectsObjs );//scene.children

				if ( intersects.length > 0 )
				{
					if ( INTERSECTED != intersects[ 0 ].object )
					{
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0x222222 );
					}
				} else {
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
				}
				
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>