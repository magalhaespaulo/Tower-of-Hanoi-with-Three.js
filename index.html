<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive cubes</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/Stats.js" type="text/javascript"></script>
		<script src="js/Tween.js" type="text/javascript"></script>
		<script src="js/greensock/TweenMax.min.js" type="text/javascript"></script>
		<script src="js/jquery-1.8.2.min.js" type="text/javascript"></script>

		<script>

			var container, stats;
			var camera,controls, scene, projector, renderer;

			var mouse = { x: 0, y: 0 }, INTERSECTED;
			
			var geometry, cube, object, obj;

var tAarray = [];
var tBarray = [];
var tCarray = [];
var discos = [];
var movimentos_origem = [];
var movimentos_destino = [];
var movimentos_count = 1;
var aux = 0;
var automatico=true;
var quantidade_discos = 3;
var escolher_quantidade_discos = [quantidade_discos,4,3,4,5,6,7,8,9,10,11,12,13,14,15];
var spaco = 6;
var velocidadeTorres = .205002372;
var cores_discos=[0xCC0000,0x009900,0x3333FF,0x993366,0x666666];

var altura_torres = 50*(quantidade_discos*.25);
var torre_a_x = -altura_torres*2; //*altura_torres*.02;
var torre_b_x = 0;
var torre_c_x = altura_torres*2;

var base, torreA, torreB, torreC;

var discos_scene;

var tl = new TimelineLite();

pre_init();
init();

function pre_init(){
	
	container = document.createElement( 'div' );
	document.body.appendChild( container );
 

	var textos = document.createElement( 'div' );
	textos.style.position = 'absolute';
	textos.style.top = '20px';
	textos.style.width = '100%';
	textos.style.textAlign = 'center';
	textos.id = 'textos';
	textos.innerHTML = '<input type="checkbox" id="automatico" //checked="checked">Automatico</input><div id"infors"><select id="select"></select><input type="button" id="iniciar" value="Iniciar" onclick="init()" /></div>';
	container.appendChild( textos );


	var select = document.getElementById("select");
	for(index in escolher_quantidade_discos) {
		select.options[select.options.length] = new Option( escolher_quantidade_discos[index], escolher_quantidade_discos[index] );
	}
}
function init(){
		var select = document.getElementById("select");
		quantidade_discos = select.options[select.selectedIndex].value;
		
		automatico = document.getElementById("automatico").checked;


		$('#select').remove();
		$('#iniciar').remove();
		document.getElementById('textos').innerHTML = '<div>Movimento: <b id="movimentos">0</b></div>';
		
		
		init_3D();
		animate();
		init_solution();
}
			function init_3D( )
			{

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 50;
				camera.position.z = 300;
				
				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( -1, -1, -1 ).normalize();
				scene.add( light );

				geometry = new THREE.TorusGeometry( 20, spaco/2, spaco );
				cube_base = new THREE.CubeGeometry( altura_torres*8, altura_torres*2, 2 );
				cube = new THREE.CubeGeometry( 8*altura_torres*.02, 8*altura_torres*.02, altura_torres );

				base = new THREE.Mesh( cube_base, new THREE.MeshLambertMaterial( { color: 0x663300 /*Math.random() * 0xffffff*/ } ) );
				base.position.set(0,-3,0);
				base.rotation.x = -Math.PI/2;
				scene.add( base );
				torreA = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreA.position.set(torre_a_x, altura_torres/2-3, 0);
				torreA.rotation.set(-Math.PI/2, 0, 0);
				torreA.name = "A";
				scene.add( torreA );
				torreB = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreB.position.set(torre_b_x, altura_torres/2-3, 0);
				torreB.rotation.set(-Math.PI/2, 0, 0);
				torreB.name = "B";
				scene.add( torreB );
				torreC = new THREE.Mesh( cube, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreC.position.set(torre_c_x, altura_torres/2-3, 0);
				torreC.rotation.set(-Math.PI/2, 0, 0);
				torreC.name = "C";
				scene.add( torreC );

var extrudeSettings = { amount: spaco/3,
					bevelSegments: 12,
					steps: 2,
					bevelSegments: 5,
					bevelSize: 2, 
					bevelThickness:spaco/3 };


				
					

					
					

					


				for ( var i = 0; i<quantidade_discos; i++ )
				{ // = ( Math.random() * 360 ) * Math.PI / 180;
				/*
					var disco = "disco"+i;
					eval(disco + " = THREE.SceneUtils.createMultiMaterialObject( new THREE.ExtrudeGeometry( arcShape2, extrudeSettings ), [ new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ] )");
					//eval(disco + " = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff  } ) )"); //cores_discos[i]
					eval(disco + ".rotation.x = -Math.PI/2");
					eval(disco + ".position.set(-i,((quantidade_discos-1)*spaco)+(-i*spaco),i)");//".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");
					eval(disco + ".scale.set(.6+i*altura_torres*.002,.6+i*altura_torres*.002,1)");
					eval(disco + ".id = i");
					discos_scene.add( eval(disco) );

					tAarray.push( eval(disco).id );
				*/
/*
its works*/

				var arcShape2 = new THREE.Shape();
				arcShape2.absarc( 10, 10, 20+(i*4), 0, Math.PI*2, false );

				var holePath2 = new THREE.Shape();
				holePath2.absarc( 10, 10, 15, 0, Math.PI*2, true );
				arcShape2.holes.push( holePath2 );

					var disc = "disco"+i;
					eval(disc + "= new THREE.Object3D()");
					var object_disc = THREE.SceneUtils.createMultiMaterialObject( new THREE.ExtrudeGeometry( arcShape2, extrudeSettings ), [ new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ] );
					object_disc.rotation.x = -Math.PI/2;
					object_disc.position.set(-10,0,10);
					eval(disc + ".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");//".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");
					eval(disc).id = i;
					eval(disc).add( object_disc );
					scene.add( eval(disc) );

/*
its works
					var disc = "disco"+i;
					eval(disc + "= new THREE.Object3D()");
					var NUM = .75+i*altura_torres*.003;
					var object_disc = THREE.SceneUtils.createMultiMaterialObject( new THREE.ExtrudeGeometry( arcShape2, extrudeSettings ), [ new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ] );
					object_disc.rotation.x = -Math.PI/2;
					object_disc.position.set(-10*NUM,0,10*NUM);
					object_disc.scale.set(NUM,NUM,1);
					eval(disc + ".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");//".position.set(torre_a_x,((quantidade_discos-1)*spaco)+(-i*spaco),0)");
					eval(disc).id = i;
					eval(disc).add( object_disc );
					scene.add( eval(disc) );
*/
					tAarray.push( eval(disc).id );
				}

				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer();
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeydown, false );

				window.addEventListener( 'resize', onWindowResize, false );
				
TweenLite.ticker.addEventListener("tick", render);
				
			}

function subir( disco, origem, destino )
{
console.log(origem + " " +destino);
console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
	obj = eval("disco"+disco);
	
	if( origem == 'A' ) tAarray.sort().shift(); 
	if( origem == 'B' ) tBarray.sort().shift();
	if( origem == 'C' ) tCarray.sort().shift();

	if ( destino == 'A' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeOut, onComplete: torre_A} );
	else if ( destino == 'B' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeOut, onComplete: torre_B} );
	else if ( destino == 'C' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeOut, onComplete: torre_C} );
	else tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeOut } );

	if ( !automatico ) {
		document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'mousedown', onDocumentMouseDownTorres, false );
	}
}

function descer( destino )
{
	if ( destino == 'A' || destino == 'B' || destino == 'C')
	{
		if ( destino == 'A' ) torre_A(obj);
		if ( destino == 'B' ) torre_B(obj);
		if ( destino == 'C' ) torre_C(obj);
		
		document.removeEventListener( 'mousedown', onDocumentMouseDownTorres, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		obj = null;
	}
}


function proximo()
{
	if ( automatico && discos.length-1 > aux )
	{
		aux++;
		subir( discos[aux]-1, movimentos_origem[aux], movimentos_destino[aux] );
		
	}else{
		console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
	}

}

function init_solution()
{
	function hanoiArray(disco, inicio, temp, fim ){

		if ( disco == 1 ) {
			discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
		} else {
			hanoiArray( disco-1, inicio, fim, temp );
			discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
			hanoiArray( disco-1, temp, inicio, fim );
		}
	}
	hanoiArray(quantidade_discos, 'A','B','C');

	if ( automatico ) subir( discos[aux]-1, movimentos_origem[aux], movimentos_destino[aux] );

	//alert('Menor soluçao: '+movimentos.length+' movimentos.');
}




function torre_A() {
	tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_a_x/2, y:altura_torres*2}, {x:torre_a_x, y:altura_torres+5}]}, ease:Expo.easeOut } );
	tl.to(obj.position, velocidadeTorres/2, { y: tAarray.length*spaco, ease:Strong.easeOut, onComplete: proximo} );

	tAarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
}
function torre_B() {
	tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_b_x/2, y:altura_torres*2}, {x:torre_b_x, y:altura_torres+5}]}, ease:Expo.easeOut });
	tl.to(obj.position, velocidadeTorres/2, { y: tBarray.length*spaco, ease:Strong.easeOut, onComplete: proximo});
	
	tBarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
}
function torre_C() {
	tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_c_x/2, y:altura_torres*2}, {x:torre_c_x, y:altura_torres+5}]}, ease:Expo.easeOut } );
	tl.to(obj.position, velocidadeTorres/2, { y: tCarray.length*spaco, ease:Strong.easeOut, onComplete: proximo} );

	tCarray.unshift(obj.id);
	document.getElementById('movimentos').innerHTML = movimentos_count++;
}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				


			}

			//

			function onDocumentMouseDownTorres( event ) {

				event.preventDefault();
				

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{

					descer( intersects[0].object.name );//subir( intersects[0].object.name, intersects[0].object.id );

				}

			}
			
			
			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );
				
				if ( intersects.length > 0 ) 
				{
/*
					new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
						//x: Math.random() * 50 - 25,
						//z: Math.random() * 50 - 25,
						y: Math.random() * 50 - 25 }, 1000 )
					.easing( TWEEN.Easing.Cubic.EaseOut).start();*/
/*
					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: ( Math.random() * 360 ) * Math.PI / 180,
						y: ( Math.random() * 360 ) * Math.PI / 180,
						z: ( Math.random() * 360 ) * Math.PI / 180 }, 1000 )
					.easing( TWEEN.Easing.Elastic.EaseOut).start();*/
//alert( intersects[0].object.name );
/*
if(intersects[0].object.position.x == -50) torre = 'torre A';
if(intersects[0].object.position.x == 0) torre = 'torre B';
if(intersects[0].object.position.x == 50) torre = 'torre C';
*/
//alert(intersects[0].object.id);
subir( intersects[0].object.id );//subir( intersects[0].object.name, intersects[0].object.id );


//TweenLite.to(intersects[0].object.position, .5, { y: 50, ease: Sine.easeOut, onComplete:vai_c( intersects[0].object.name )});





					
					//alert(intersects[0].object.name);
					
					

					
					//a_c(intersects[ 0 ].object);
//intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );



					
					
					//alert("you clicked particle named '" + intersects[0].object.name + "' with id: " + intersects[0].object.id);

				}

			}





			
			function onDocumentKeydown( event ) {

				switch(event.keyCode) {
					case 32: paused = paused ? false : true; break;
					case 38: camera.position.z -= 10; break;
					case 40: camera.position.z += 10; break;
				}
			}



			function animate() {

				requestAnimationFrame( animate );
				controls.update();
				
				render();
				stats.update();

			}


			var radius = 100;
			var theta = 0;



			function render() {

				theta += 0.2;
				
				
TWEEN.update();////////////////

/**/
				scene.position.y = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				scene.position.x = radius * Math.sin( (mouse.x*30) * Math.PI / 360 );
				scene.position.z = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				/*camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );*/

				camera.lookAt( scene.position );

				// find intersections

				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						//INTERSECTED.material.emissive.setHex( 0xff0a00 );

					}


				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
