<!DOCTYPE html>
<html lang="pt-BR">
	<head>
		<title>Tower of Hanoi with Three.js</title>	
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.min.js" type="text/javascript"></script>
		<script src="js/Stats.js" type="text/javascript"></script>
		<script src="js/Tween.js" type="text/javascript"></script>
		<script src="js/greensock/TweenMax.min.js" type="text/javascript"></script>
		<script src="js/jquery-1.8.2.min.js" type="text/javascript"></script>
		<script src="js/dat.gui.min.js" type="text/javascript"></script>

		<script>

		var container, stats, camera, controls, scene, projector, renderer,

		mouse = new THREE.Vector2(), offset = new THREE.Vector3(), INTERSECTED, SELECTED,
		
		geometry, cube, object, obj,

		base, torreA, torreB, torreC,
		tAarray = [], tBarray = [], tCarray = [], discos = [], movimentos_origem = [], movimentos_destino = [],
		movimentos_count = 1,
		aux = 0,
		automatico=true,
		quantidade_discos = 5,
		escolher_quantidade_discos = [quantidade_discos,3,4,5,6,7,8,9,10,11,12,13,14,15],
		spaco = 8,
		velocidadeTorres = .075,
		cores_discos=[0xCC0000,0x009900,0x3333FF,0x993366,0x666666],

		altura_torres = 50*(quantidade_discos*.25),
		torre_a_x = -altura_torres*1.5,
		torre_b_x = 0,
		torre_c_x = altura_torres*1.5,

		tl = new TimelineLite(),

		torresObjs = [],//testing
		discosObjs = [];//testing

		//let's rock
			pre_init();
			init();

		//pre_init
			function pre_init()
			{
				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var textos = document.createElement( 'div' );
				textos.style.position = 'absolute';
				textos.style.top = '20px';
				textos.style.width = '100%';
				textos.style.textAlign = 'center';
				textos.id = 'textos';
				textos.innerHTML = '<input type="checkbox" id="automatico" checked="checked">Automatico</input><div id"infors"><select id="select"></select><input type="button" id="iniciar" value="Iniciar" onclick="init()" /></div>';
				container.appendChild( textos );

				var select = document.getElementById("select");
				for(index in escolher_quantidade_discos) {
					select.options[select.options.length] = new Option( escolher_quantidade_discos[index], escolher_quantidade_discos[index] );
				}
			}

		//init
			function init()
			{
				var select = document.getElementById("select");
				quantidade_discos = select.options[select.selectedIndex].value;
				automatico = document.getElementById("automatico").checked;

				$('#select').remove();
				$('#iniciar').remove();
				document.getElementById('textos').innerHTML = '<div>Movimento: <b id="movimentos">0</b></div>';

				init_3D();
				animate();
				init_solution();
			}

		//init_3D
			function init_3D( )
			{
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 50;
				camera.position.z = 300;
				
				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();

				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );
				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( -1, -1, -1 ).normalize();
				scene.add( light );

				base_geometry = new THREE.CubeGeometry( altura_torres*6, altura_torres*2, 12 );
				torre_geometry = new THREE.CylinderGeometry(6, 6, altura_torres, 12, false);

				base = new THREE.Mesh( base_geometry, new THREE.MeshLambertMaterial( { color: 0x663300 /*Math.random() * 0xffffff*/ } ) );
				base.position.set(0,-8,0);
				base.rotation.x = -Math.PI/2;
				scene.add( base );
				torreA = new THREE.Mesh( torre_geometry, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreA.position.set(torre_a_x, altura_torres/2-2, 0);
				torreA.name = "A";
				torresObjs.push( torreA );
				scene.add( torreA );
				torreB = new THREE.Mesh( torre_geometry, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreB.position.set(torre_b_x, altura_torres/2-2, 0);
				torreB.name = "B";
				torresObjs.push( torreB );
				scene.add( torreB );
				torreC = new THREE.Mesh( torre_geometry, new THREE.MeshLambertMaterial( { color: 0x663300 } ) );
				torreC.position.set(torre_c_x, altura_torres/2-2, 0);
				torreC.name = "C";
				torresObjs.push( torreC );
				scene.add( torreC );

				var extrudeSettings = {
					amount: spaco/3,
					steps: 2,
					bevelSegments: 22,
					bevelSize: 11, 
					bevelThickness: spaco/3 };

				j = quantidade_discos-1;
				for ( var i = 0; i<quantidade_discos; i++ )
				{

					var arcShape = new THREE.Shape();
					arcShape.absarc( 0, 0, 20+(i*4), 0, Math.PI*2, false );
					var holePath = new THREE.Shape();
					holePath.absarc( 0, 0,18, 0, Math.PI*2, true );
					arcShape.holes.push( holePath );

					var disco = "disco"+i;
					eval(disco + " = new THREE.Mesh( new THREE.ExtrudeGeometry( arcShape, extrudeSettings ), new THREE.MeshLambertMaterial( { color: cores_discos[i]  } ) )"); //Math.random() * 0xffffff
					eval(disco + ".rotation.x = -Math.PI/2");// = ( Math.random() * 360 ) * Math.PI / 180;
					eval(disco + ".position.set(torre_a_x,j*spaco,0)");
					eval(disco + ".id = i");
					eval(disco + ".name = i");
					scene.add( eval(disco) );
					discosObjs.push( eval(disco) );
					tAarray.push( eval(disco).id );
					j--;
				}
			
				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild(renderer.domElement);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				if ( !automatico ) document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				//document.addEventListener( 'keydown', onDocumentKeydown, false );

				window.addEventListener( 'resize', onWindowResize, false );
				
				TweenLite.ticker.addEventListener("tick", render);
			}

		//subir
			function subir( disco, origem, destino )
			{
				//console.log(origem + " " +destino);
				//console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
				obj = eval("disco"+disco);

				if( origem == 'A' ) tAarray.sort().shift(); 
				if( origem == 'B' ) tBarray.sort().shift();
				if( origem == 'C' ) tCarray.sort().shift();

				if ( destino == 'A' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn, onComplete: torre_A} );
				else if ( destino == 'B' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn, onComplete: torre_B} );
				else if ( destino == 'C' ) tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn, onComplete: torre_C} );
				else tl.to(obj.position, velocidadeTorres, { y: altura_torres+10, ease:Expo.easeIn } );

				if ( !automatico ) {
					document.removeEventListener( 'mousedown', onDocumentMouseDown, false );
					document.addEventListener( 'mousedown', onDocumentMouseDownTowers, false );
				}
			}

		//descer
			function descer( destino )
			{
				if ( destino == 'A' || destino == 'B' || destino == 'C')
				{
					if ( destino == 'A' ) torre_A(obj);
					if ( destino == 'B' ) torre_B(obj);
					if ( destino == 'C' ) torre_C(obj);
					
					document.removeEventListener( 'mousedown', onDocumentMouseDownTowers, false );
					document.addEventListener( 'mousedown', onDocumentMouseDown, false );
					obj = null;
				}
			}

		//proximo
			function proximo()
			{
				if ( automatico && discos.length-1 > aux )
				{
					aux++;
					subir( discos[aux]-1, movimentos_origem[aux], movimentos_destino[aux] );
					
				}else{
					console.log("A: " + tAarray + " B: " + tBarray + " C: "+ tCarray);
				}

			}

		//init_solution
			function init_solution()
			{
				function hanoiArray(disco, inicio, temp, fim ){

					if ( disco == 1 ) {
						discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
					} else {
						hanoiArray( disco-1, inicio, fim, temp );
						discos.push(disco); movimentos_origem.push(inicio); movimentos_destino.push(fim);
						hanoiArray( disco-1, temp, inicio, fim );
					}
				}
				hanoiArray(quantidade_discos, 'A','B','C');

				if ( automatico ) subir( discos[aux]-1, movimentos_origem[aux], movimentos_destino[aux] );

				//console.log('Menor soluçao: '+movimentos.length+' movimentos.');
			}

		//torre_A
			function torre_A()
			{
				tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_a_x/2, y:altura_torres*2}, {x:torre_a_x, y:altura_torres+10}]}, ease:Quart.easeOut } );
				tl.to(obj.position, velocidadeTorres/2, { y: tAarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo} );

				tAarray.unshift(obj.id);
				document.getElementById('movimentos').innerHTML = movimentos_count++;
			}
		//torre_B
			function torre_B()
			{
				tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_b_x/2, y:altura_torres*2}, {x:torre_b_x, y:altura_torres+10}]}, ease:Quart.easeOut });
				tl.to(obj.position, velocidadeTorres/2, { y: tBarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo});
				
				tBarray.unshift(obj.id);
				document.getElementById('movimentos').innerHTML = movimentos_count++;
			}
		//torre_C
			function torre_C()
			{
				tl.to(obj.position, velocidadeTorres*2, { bezier:{type:"soft", values:[{x:torre_c_x/2, y:altura_torres*2}, {x:torre_c_x, y:altura_torres+10}]}, ease:Quart.easeOut } );
				tl.to(obj.position, velocidadeTorres/2, { y: tCarray.length*spaco, ease:Bounce.easeOut, onComplete: proximo} );

				tCarray.unshift(obj.id);
				document.getElementById('movimentos').innerHTML = movimentos_count++;
			}

		//onWindowResize
			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

		//onDocumentMouseMove
			function onDocumentMouseMove( event )
			{
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

		//onDocumentMouseDown
			function onDocumentMouseDown( event )
			{
				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( discosObjs );//scene.children
				
				if ( intersects.length > 0 ) 
				{
					//console.log(intersects[0].object.name);
					//console.log(intersects[0].object.id);
					
					if ( intersects[0].object.position.x == torre_a_x ) var origem = "A";
					else if ( intersects[0].object.position.x == torre_b_x ) var origem = "B";
					else if ( intersects[0].object.position.x == torre_c_x ) var origem = "C";

					subir( intersects[0].object.id, origem );//subir( disco, origem, destino )
				}
			}

		//onDocumentMouseDownTowers
			function onDocumentMouseDownTowers( event )
			{
				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( torresObjs );//scene.children

				if ( intersects.length > 0 )
				{
					//console.log(intersects[0].object.name);
					//console.log(intersects[0].object.id);
					
					descer( intersects[0].object.name );//descer( destino )
				}
			}

		//onDocumentKeydown
			function onDocumentKeydown( event )
			{
				switch(event.keyCode)
				{
					case 32: paused = paused ? false : true; break;
					case 38: camera.position.z -= 10; break;
					case 40: camera.position.z += 10; break;
				}
			}

		//animate
			function animate()
			{
				requestAnimationFrame( animate );
				controls.update();
				
				render();
				stats.update();
			}

		var radius = 100, theta = 0;
		//render
			function render()
			{

				theta += 0.2;
				
				TWEEN.update();

				scene.position.y = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				scene.position.x = radius * Math.sin( (mouse.x*30) * Math.PI / 360 );
				scene.position.z = radius * Math.sin( (mouse.y*30) * Math.PI / 360 );
				/*camera.position.y = radius * Math.sin( theta * Math.PI / 360 );
				camera.position.z = radius * Math.cos( theta * Math.PI / 360 );*/

				camera.lookAt( scene.position );

				// find intersections
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( scene.children );

				if ( intersects.length > 0 )
				{
					if ( INTERSECTED != intersects[ 0 ].object )
					{
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0a00 );
					}
				}
				else
				{

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;
				}
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>